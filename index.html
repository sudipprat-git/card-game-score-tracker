<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Game Score Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }
        /* Light mode styles */
        .light {
            background-color: #f0f4f8; /* Light background */
            color: #1a202c; /* Dark text */
        }
        .light .bg-card {
            background-color: #ffffff;
        }
        .light .border-input {
            border-color: #cbd5e0;
        }
        .light .text-muted-foreground {
            color: #718096;
        }
        .light .hover\:bg-gray-100:hover {
            background-color: #f7fafc;
        }
        /* Custom highlight colors for light mode - Adjusted for better contrast */
        .light .highlight-winner {
            background-color: #96e4b3; 
        }
        .light .highlight-loser {
            background-color: #f79f9f; 
        }
        .light .bg-blue-500 {
            background-color: #3b82f6;
        }
        .light .bg-blue-600 {
            background-color: #2563eb;
        }

        /* Dark mode styles */
        .dark {
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }
        .dark .bg-card {
            background-color: #2d3748;
        }
        .dark .border-input {
            border-color: #4a5568;
        }
        .dark .text-muted-foreground {
            color: #a0aec0;
        }
        .dark .hover\:bg-gray-700:hover {
            background-color: #4a5568;
        }
        /* Custom highlight colors for dark mode */
        .dark .highlight-winner {
            background-color: #41df7d; /* Tailwind green-800 */
        }
        .dark .highlight-loser {
            background-color: #e66464; /* Tailwind red-800 */
        }
        .dark .bg-blue-500 {
            background-color: #3b82f6;
        }
        .dark .bg-blue-600 {
            background-color: #2563eb;
        }

        /* General table styling for fixed header/column */
        .sticky-header th, .sticky-header td {
            position: sticky;
            top: 0;
            background-color: inherit; /* Inherit background from parent to match theme */
            z-index: 10; /* Ensure header is above scrolling content */
        }

        .sticky-first-col th:first-child,
        .sticky-first-col td:first-child {
            position: sticky;
            left: 0;
            background-color: inherit; /* Inherit background from parent to match theme */
            z-index: 11; /* Ensure first column is above scrolling content and header */
        }

        .table-container {
            max-height: 70vh; /* Limit height for scrolling */
            overflow: auto; /* Enable scrolling for the table content */
            border-radius: 0.5rem;
        }

        /* Custom tooltip styles */
        .tooltip-container {
            position: relative; /* This makes the absolute positioning of tooltip-text relative to this container */
            display: inline-block; /* Allows it to sit next to the button */
            /* No need for group:hover here, as the info icon is separate */
        }

        .tooltip-text {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 100;
            bottom: 125%; /* Position above the info icon */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.875rem;
            pointer-events: none; /* Allows clicks to pass through to elements behind if tooltip is not active */
            max-width: 200px; /* Added max-width to prevent excessive width */
        }

        /* New class for active tooltips (for touch devices) */
        .tooltip-text.active {
            visibility: visible;
            opacity: 1;
            pointer-events: auto; /* Re-enable pointer events when active */
        }

        /* Original hover effect for non-touch devices - applies to the info icon now */
        @media (hover: hover) and (pointer: fine) {
            .tooltip-container:hover .tooltip-text {
                visibility: visible;
                opacity: 1;
            }
        }


        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            align-items: center; /* Use flexbox for centering content */
            justify-content: center; /* Use flexbox for centering content */
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative; /* Keep relative for inner elements */
            /* Animation properties */
            animation: fadeInScale 0.3s ease-out forwards;
            /* Removed absolute positioning for flexbox centering */
        }
        .dark .modal-content {
            background-color: #2d3748;
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .dark .close-button:hover,
        .dark .close-button:focus {
            color: white;
        }

        /* Input number arrows styling */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }

        /* Animations for Winner Modal */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8); /* Scale from center */
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulseAward {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Specific animations for each place to create a staggered effect */
        @keyframes bounceIn1 {
            0% { opacity: 0; transform: translateY(50px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes bounceIn2 {
            0% { opacity: 0; transform: translateY(50px); }
            50% { opacity: 0; } /* Delay */
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes bounceIn3 {
            0% { opacity: 0; transform: translateY(50px); }
            75% { opacity: 0; } /* Longer delay */
            100% { opacity: 1; transform: translateY(0); }
        }

        .animate-pop-in {
            animation: popIn 0.5s ease-out;
        }

        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        .animate-fade-in.delay-1s {
            animation-delay: 1s;
        }

        .animate-pulse-award {
            animation: pulseAward 1.5s infinite ease-in-out;
        }

        .animate-bounce-in-1 { animation: bounceIn1 0.6s ease-out forwards; }
        .animate-bounce-in-2 { animation: bounceIn1 0.6s ease-out 0.2s forwards; opacity: 0; } /* Staggered */
        .animate-bounce-in-3 { animation: bounceIn1 0.6s ease-out 0.4s forwards; opacity: 0; } /* Staggered */

        /* Ensure awards are large */
        #winnerResults span {
            display: inline-block; /* Essential for transform animations */
        }

        /* New styles for active input and header highlight */
        .highlight-input {
            background-color: rgba(60, 150, 255, 0.1); /* Light blue highlight */
            border-color: #3b82f6; /* Blue border */
        }
        .dark .highlight-input {
            background-color: rgba(59, 130, 246, 0.2); /* Darker blue highlight */
        }
        .highlight-player-header {
            background-color: #bfdbfe; /* Light blue for header */
        }
        .dark .highlight-player-header {
            background-color: #1e3a8a; /* Darker blue for header */
        }

        /* Score change animation */
        @keyframes scoreChangeFade {
            0% { background-color: #a7f3d0; } /* Light green for change */
            100% { background-color: transparent; }
        }
        .dark @keyframes scoreChangeFade {
            0% { background-color: #065f46; } /* Dark green for change */
            100% { background-color: transparent; }
        }
        .score-changed {
            animation: scoreChangeFade 0.5s ease-out;
        }

        /* Screenshot loading modal specific styles */
        #screenshotLoadingModal .modal-content {
            padding: 40px; /* More padding for a larger spinner */
            max-width: 300px;
        }

        /* Shake animation for error message */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .shake-animation {
            animation: shake 0.5s;
        }

        /* Edit icon styling */
        .edit-icon {
            margin-left: 8px; /* Space between round number and icon */
            cursor: pointer;
            color: #6b7280; /* Gray color */
            transition: color 0.2s ease-in-out;
        }
        .edit-icon:hover {
            color: #3b82f6; /* Blue on hover */
        }
        .dark .edit-icon {
            color: #9ca3af;
        }
        .dark .edit-icon:hover {
            color: #60a5fa;
        }

        /* Style for the latest round's edit icon (always unlocked) */
        .edit-icon.latest-round-active {
            color: #3b82f6; /* Blue color for active */
        }
        .dark .edit-icon.latest-round-active {
            color: #60a5fa; /* Lighter blue for active in dark mode */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4 transition-colors duration-300">

    <div class="w-full max-w-4xl bg-card rounded-lg shadow-xl p-6 md:p-8 transition-colors duration-300 relative">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-8 bg-clip-text text-transparent bg-gradient-to-r from-amber-600 to-amber-800">Card Game Score Tracker</h1>

        <div class="absolute top-4 right-4 z-50">
            <button id="darkModeToggle" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                <i id="darkModeIcon" class="fas mr-2 group-scope-hover:scale-110 transition-transform"></i> <span id="darkModeText"></span>
            </button>
        </div>

        <div id="playerCountScreen" class="space-y-6">
            <div class="flex flex-col items-center">
                <label for="numPlayers" class="text-2xl md:text-3xl font-semibold text-center mb-6">How many people playing?</label>
                <input type="number" id="numPlayers" min="2" max="10" placeholder="Enter a number between 2 and 10"
                       class="w-full md:w-1/2 p-3 border border-input rounded-md text-center text-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-transparent">
                <p id="playerCountError" class="text-red-500 text-sm mt-2 hidden">Please enter a number between 2 and 10.</p>
            </div>
            <div class="flex justify-center items-center">
                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-blue-500/10 dark:group-hover:bg-blue-500/20">
                    <button id="nextToPlayerNames"
                            class="bg-blue-600 hover:bg-blue-800 text-gray-200 font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope">
                        Next: Enter Player Names <i class="fas fa-arrow-right ml-2 group-scope-hover:translate-x-1 transition-transform"></i>
                    </button>
                </div>
            </div>
        </div>

        <div id="playerNamesScreen" class="hidden space-y-6">
            <h2 class="text-2xl md:text-3xl font-semibold text-center mb-6">Who all are playing?</h2>
            <div id="playerInputsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                </div>
            <p id="playerNamesError" class="text-red-500 text-sm mt-2 hidden text-center">Please enter names for all players.</p>
            <div class="flex justify-center gap-4 items-center">
                <div id="backToPlayerCountGroup" class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-gray-300/50 dark:group-hover:bg-gray-700/50">
                    <button id="backToPlayerCount"
                            class="bg-blue-600 hover:bg-blue-800 text-gray-200 font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope">
                        <i class="fas fa-arrow-left mr-2 group-scope-hover:-translate-x-1 transition-transform"></i> Back
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="backToPlayerCountTooltip"></i>
                        <span class="tooltip-text" id="backToPlayerCountTooltip">Go back to change number of players.</span>
                    </div>
                </div>

                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-blue-500/10 dark:group-hover:bg-blue-500/20">
                    <button id="confirmPlayerNames"
                            class="bg-blue-600 hover:bg-blue-800 text-gray-200 font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope">
                        <span id="confirmPlayerNamesText">Start Game</span> <i class="fas fa-play ml-2 group-scope-hover:scale-110 transition-transform"></i>
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="confirmPlayerNamesTooltip"></i>
                        <span class="tooltip-text" id="confirmPlayerNamesTooltip">Start the game with these players.</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="scoreboardScreen" class="hidden space-y-6 relative">
            

            <div class="flex flex-wrap justify-center gap-x-4 gap-y-2 mb-6 items-center">
                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-purple-500/10 dark:group-hover:bg-purple-500/20">
                    <button id="editPlayerNames"
                            class="bg-blue-600 hover:bg-blue-800 text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                        <i class="fas fa-user-edit mr-2 group-scope-hover:rotate-6 transition-transform"></i> Edit Player Names
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="editPlayerNamesTooltip"></i>
                        <span class="tooltip-text" id="editPlayerNamesTooltip">Edit player names without losing scores.</span>
                    </div>
                </div>

                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-green-500/10 dark:group-hover:bg-green-500/20">
                    <button id="screenshotBtn"
                            class="bg-blue-600 hover:bg-blue-800 text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                        <i class="fas fa-camera mr-2 group-scope-hover:scale-110 transition-transform"></i> Screenshot
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="screenshotBtnTooltip"></i>
                        <span class="tooltip-text" id="screenshotBtnTooltip">Generate a screenshot of the scoreboard.</span>
                    </div>
                </div>
            </div>

            <div class="table-container bg-gray-100 dark:bg-gray-800 rounded-lg shadow-inner">
                <table id="scoreTable" class="w-full text-left border-collapse">
                    <thead class="sticky-header">
                        <tr class="bg-gray-200 dark:bg-gray-700">
                            <th class="p-3 border-r border-gray-300 dark:border-gray-600 sticky-first-col rounded-tl-lg text-gray-800 dark:text-gray-200">Round</th>
                            </tr>
                    </thead>
                    <tbody id="scoreTableBody">
                        </tbody>
                </table>
            </div>

            <div class="flex flex-wrap justify-center gap-x-4 gap-y-2 mt-6 items-center">
                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-blue-500/10 dark:group-hover:bg-blue-500/20">
                    <button id="addRoundBtn"
                            class="bg-blue-600 hover:bg-blue-800 text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                        <i class="fas fa-plus-circle mr-2 group-scope-hover:rotate-6 transition-transform"></i> Add Round
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="addRoundTooltip"></i>
                        <span class="tooltip-text" id="addRoundTooltip">Add a new round to the scoreboard.</span>
                    </div>
                </div>

                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-yellow-500/10 dark:group-hover:bg-yellow-500/20">
                    <button id="hideShowRoundsBtn"
                            class="bg-yellow-600 hover:bg-yellow-800 text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope">
                        <i class="fas fa-eye-slash mr-2 group-scope-hover:scale-110 transition-transform"></i> <span id="hideShowRoundsText">Hide Old Rounds</span>
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="hideShowRoundsTooltip"></i>
                        <span class="tooltip-text" id="hideShowRoundsTooltip">Toggle visibility of old rounds (show last 3).</span>
                    </div>
                </div>

                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-orange-500/10 dark:group-hover:bg-orange-500/20">
                    <button id="clearScoresBtn"
                            class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                        <i class="fas fa-eraser mr-2 group-scope-hover:rotate-6 transition-transform"></i> Clear Scores
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="clearScoresTooltip"></i>
                        <span class="tooltip-text" id="clearScoresTooltip">Clear all scores and start a new game with current players.</span>
                    </div>
                </div>

                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-red-500/10 dark:group-hover:bg-red-500/20">
                    <button id="endGameBtn"
                            class="bg-teal-600 hover:bg-teal-800 text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                        <i class="fas fa-trophy mr-2 group-scope-hover:scale-110 transition-transform"></i> Finish Game & See Ranks
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="endGameTooltip"></i>
                        <span class="tooltip-text" id="endGameTooltip">Declare winners.</span>
                    </div>
                </div>

                <div class="flex items-center group rounded-lg p-2 transition-colors duration-300 group-hover:bg-gray-500/10 dark:group-hover:bg-gray-500/20">
                    <button id="resetGameBtn"
                            class="bg-red-600 hover:bg-red-800 text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 flex items-center group-scope text-sm md:text-base">
                        <i class="fas fa-trash mr-2 group-scope-hover:rotate-180 transition-transform"></i> Reset Game
                    </button>
                    <div class="tooltip-container ml-2">
                        <i class="fas fa-info-circle text-gray-600 dark:text-gray-400 cursor-pointer text-xl" data-tooltip-target="resetGameTooltip"></i>
                        <span class="tooltip-text" id="resetGameTooltip">Clear all data and restart the game from scratch.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="winnerModal" class="modal">
        <div class="modal-content text-center p-8 relative overflow-hidden">
            <span class="close-button">&times;</span>
            <h3 class="text-4xl md:text-5xl font-extrabold mb-6 text-yellow-500 dark:text-yellow-300 animate-pop-in">
                <i class="fas fa-crown mr-2"></i> Congratulations! <i class="fas fa-trophy ml-2"></i>
            </h3>
            <p class="text-xl md:text-2xl font-semibold mb-8 text-teal dark:text-gray-800 animate-fade-in">
                What an epic battle! Here are today's champions!
            </p>
            <div id="winnerResults" class="space-y-6 text-lg">
                </div>
            <button id="closeWinnerModal"
                    class="mt-10 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 animate-fade-in delay-1s">
                Close!
            </button>
        </div>
    </div>

    <div id="confirmationModal" class="modal">
        <div class="modal-content text-center">
            <span class="close-button" id="closeConfirmationModal">&times;</span>
            <h3 class="text-2xl font-bold mb-4" id="confirmationModalTitle"></h3>
            <p class="text-lg mb-6" id="confirmationModalMessage"></p>
            <div class="flex justify-center gap-4">
                <button id="confirmActionButton"
                        class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105">
                    Confirm
                </button>
                <button id="cancelActionButton"
                        class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <div id="screenshotLoadingModal" class="modal">
        <div class="modal-content text-center p-8">
            <i class="fas fa-spinner fa-spin text-5xl text-blue-500 mb-4"></i>
            <p class="text-xl font-semibold">Generating screenshot...</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        // Global state object
        let gameState = {
            playerCount: 0,
            playerNames: [],
            rounds: [] // Each round is an array of scores, e.g., [10, -5, 20]
        };

        // Flag to track if we are in player name editing mode
        let isEditingPlayerNames = false;
        // Track which round is currently being edited (null if none)
        let currentlyEditingRoundIndex = null;

        // DOM Elements
        const playerCountScreen = document.getElementById('playerCountScreen');
        const numPlayersInput = document.getElementById('numPlayers');
        const playerCountError = document.getElementById('playerCountError');
        const nextToPlayerNamesBtn = document.getElementById('nextToPlayerNames');

        const playerNamesScreen = document.getElementById('playerNamesScreen');
        const playerInputsContainer = document.getElementById('playerInputsContainer');
        const playerNamesError = document.getElementById('playerNamesError');
        const backToPlayerCountBtn = document.getElementById('backToPlayerCount');
        const backToPlayerCountGroup = document.getElementById('backToPlayerCountGroup'); // New: reference to the group div
        const confirmPlayerNamesBtn = document.getElementById('confirmPlayerNames');
        const confirmPlayerNamesText = document.getElementById('confirmPlayerNamesText');
        const confirmPlayerNamesTooltip = document.getElementById('confirmPlayerNamesTooltip');


        const scoreboardScreen = document.getElementById('scoreboardScreen');
        const scoreTable = document.getElementById('scoreTable');
        const scoreTableBody = document.getElementById('scoreTableBody');
        const addRoundBtn = document.getElementById('addRoundBtn');
        const editPlayerNamesBtn = document.getElementById('editPlayerNames');
        const screenshotBtn = document.getElementById('screenshotBtn');
        const clearScoresBtn = document.getElementById('clearScoresBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        const hideShowRoundsBtn = document.getElementById('hideShowRoundsBtn');
        const hideShowRoundsText = document.getElementById('hideShowRoundsText');
        const hideShowRoundsTooltip = document.getElementById('hideShowRoundsTooltip');
        const endGameBtn = document.getElementById('endGameBtn');

        const winnerModal = document.getElementById('winnerModal');
        const closeWinnerModalBtn = document.querySelector('#winnerModal .close-button');
        const closeWinnerModalBtn2 = document.getElementById('closeWinnerModal');
        const winnerResultsDiv = document.getElementById('winnerResults');

        // Confirmation Modal Elements
        const confirmationModal = document.getElementById('confirmationModal');
        const closeConfirmationModalBtn = document.getElementById('closeConfirmationModal');
        const confirmationModalTitle = document.getElementById('confirmationModalTitle');
        const confirmationModalMessage = document.getElementById('confirmationModalMessage');
        const confirmActionButton = document.getElementById('confirmActionButton');
        const cancelActionButton = document.getElementById('cancelActionButton');

        const screenshotLoadingModal = document.getElementById('screenshotLoadingModal');

        const darkModeToggle = document.getElementById('darkModeToggle');
        const darkModeIcon = document.getElementById('darkModeIcon'); // Get the icon element
        const darkModeText = document.getElementById('darkModeText'); // Get the text element

        // --- Local Storage Functions ---
        function saveGameState() {
            localStorage.setItem('cardGameScores', JSON.stringify(gameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem('cardGameScores');
            if (savedState) {
                gameState = JSON.parse(savedState);
            }
        }

        // --- Screen Navigation Functions ---
        function showScreen(screenId) {
            playerCountScreen.classList.add('hidden');
            playerNamesScreen.classList.add('hidden');
            scoreboardScreen.classList.add('hidden');

            document.getElementById(screenId).classList.remove('hidden');
        }

        function renderPlayerCountScreen() {
            isEditingPlayerNames = false; // Reset flag when going to player count screen
            numPlayersInput.value = gameState.playerCount > 0 ? gameState.playerCount : '';
            playerCountError.classList.add('hidden');
            showScreen('playerCountScreen');
        }

        function renderPlayerNamesScreen() {
            playerInputsContainer.innerHTML = '';
            playerNamesError.classList.add('hidden');

            // Adjust button visibility and text based on editing mode
            if (isEditingPlayerNames) {
                backToPlayerCountGroup.classList.add('hidden'); // Hide the entire group
                confirmPlayerNamesText.textContent = 'Save Changes';
                confirmPlayerNamesTooltip.textContent = 'Save changes to player names.';
                confirmPlayerNamesBtn.querySelector('i').className = 'fas fa-save ml-2 group-scope-hover:scale-110 transition-transform';
            } else {
                backToPlayerCountGroup.classList.remove('hidden'); // Show the entire group
                confirmPlayerNamesText.textContent = 'Start Game';
                confirmPlayerNamesTooltip.textContent = 'Start the game with these players.';
                confirmPlayerNamesBtn.querySelector('i').className = 'fas fa-play ml-2 group-scope-hover:scale-110 transition-transform';
            }

            for (let i = 0; i < gameState.playerCount; i++) {
                const div = document.createElement('div');
                div.className = 'flex flex-col';
                div.innerHTML = `
                    <label for="player${i + 1}Name" class="mb-1 text-muted-foreground">Player ${i + 1} Name:</label>
                    <input type="text" id="player${i + 1}Name" value="${gameState.playerNames[i] || ''}" placeholder="Player ${i + 1}"
                           class="p-2 border border-input rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-transparent">
                `;
                playerInputsContainer.appendChild(div);
            }
            showScreen('playerNamesScreen');
        }

        function renderScoreboard() {
            // Reset currently editing state when re-rendering scoreboard
            currentlyEditingRoundIndex = null;

            // Clear previous table content
            scoreTable.querySelector('thead tr').innerHTML = '<th class="p-3 border-r border-gray-300 dark:border-gray-600 sticky-first-col rounded-tl-lg text-gray-800 dark:text-gray-200">Round</th>';
            scoreTableBody.innerHTML = '';

            // Add player names to header
            gameState.playerNames.forEach((name, index) => {
                const th = document.createElement('th');
                th.className = 'p-3 border-r border-gray-300 dark:border-gray-600 text-center text-gray-800 dark:text-gray-200'; // Added text color classes
                th.textContent = name;
                th.dataset.playerIndex = index; // Store player index for highlighting
                scoreTable.querySelector('thead tr').appendChild(th);
            });
            // Add rounded top-right corner to the last player name header
            scoreTable.querySelector('thead tr th:last-child').classList.add('rounded-tr-lg');


            // Add existing rounds
            gameState.rounds.forEach((roundScores, index) => {
                addRoundRow(roundScores, index + 1);
            });

            updateTotals();
            showScreen('scoreboardScreen');

            // Apply hide/show state after rendering if rounds are supposed to be hidden
            if (roundsHidden) {
                applyHideShowRoundsState();
            }
        }

        // --- Scoreboard Functions ---
        function addRoundRow(scores = [], roundNumber) {
            const tr = document.createElement('tr');
            tr.className = 'border-t border-gray-200 dark:border-gray-700';
            tr.dataset.roundIndex = roundNumber - 1; // Store round index for easy access

            // Determine if this is the latest round (0-indexed comparison)
            const isLatestRound = (roundNumber - 1) === (gameState.rounds.length - 1);

            const roundNumTd = document.createElement('td');
            roundNumTd.className = 'p-3 border-r border-gray-200 dark:border-gray-700 font-semibold sticky-first-col flex items-center justify-between text-gray-800 dark:text-gray-200'; // Added text color classes
            
            // Conditionally add 'latest-round-active' class for the latest round's icon
            const iconClass = isLatestRound ? 'fas fa-pencil-alt edit-icon text-base latest-round-active' : 'fas fa-pencil-alt edit-icon text-base';

            roundNumTd.innerHTML = `
                <span>${roundNumber}</span>
                <i class="${iconClass}" data-round-index="${roundNumber - 1}" aria-label="Edit Round ${roundNumber} Scores"></i>
            `;
            tr.appendChild(roundNumTd);

            // Score input cells
            for (let i = 0; i < gameState.playerCount; i++) {
                const td = document.createElement('td');
                td.className = 'p-2 border-r border-gray-200 dark:border-gray-700 text-center';
                const input = document.createElement('input');
                input.type = 'number';
                input.value = scores[i] !== undefined ? scores[i] : 0;
                input.className = 'w-full p-2 rounded-md bg-transparent focus:outline-none focus:ring-1 focus:ring-blue-400 text-center text-gray-800 dark:text-gray-200'; // Added text color classes to input
                input.dataset.playerIndex = i;
                input.addEventListener('input', handleScoreInput);
                input.addEventListener('focus', handleInputFocus);
                input.addEventListener('blur', handleInputBlur);

                // Inputs are enabled ONLY if it's the current absolute last round OR if it's the currently editing round
                input.disabled = !isLatestRound && (currentlyEditingRoundIndex !== (roundNumber - 1));
                
                td.appendChild(input);
                tr.appendChild(td);
            }
            scoreTableBody.appendChild(tr);

            const editIcon = roundNumTd.querySelector('.edit-icon');
            if (editIcon) {
                // Only add click listener for non-latest rounds, as latest round is always editable
                if (!isLatestRound) {
                    editIcon.addEventListener('click', handleEditRoundClick);
                }
            }
        }

        function handleEditRoundClick(event) {
            const clickedIcon = event.currentTarget;
            const roundIndexToEdit = parseInt(clickedIcon.dataset.roundIndex);
            const targetRow = clickedIcon.closest('tr');
            const inputsInTargetRow = targetRow.querySelectorAll('input[type="number"]');

            // If the clicked round is the latest round, do nothing as it's always editable
            if (roundIndexToEdit === gameState.rounds.length - 1) {
                return;
            }

            if (currentlyEditingRoundIndex !== null && currentlyEditingRoundIndex !== roundIndexToEdit) {
                // Another row is currently being edited, lock it first
                const previousEditRow = scoreTableBody.querySelector(`tr[data-round-index="${currentlyEditingRoundIndex}"]`);
                if (previousEditRow) {
                    const inputsInPreviousRow = previousEditRow.querySelectorAll('input[type="number"]');
                    inputsInPreviousRow.forEach(input => input.disabled = true);
                    const previousEditIcon = previousEditRow.querySelector('.edit-icon');
                    if (previousEditIcon) {
                        previousEditIcon.classList.remove('fa-check');
                        previousEditIcon.classList.add('fa-pencil-alt');
                    }
                }
            }

            if (currentlyEditingRoundIndex === roundIndexToEdit) {
                // If clicking on the same row that's already being edited, lock it
                inputsInTargetRow.forEach(input => input.disabled = true);
                clickedIcon.classList.remove('fa-check');
                clickedIcon.classList.add('fa-pencil-alt');
                currentlyEditingRoundIndex = null;
            } else {
                // Unlock the clicked row
                inputsInTargetRow.forEach(input => input.disabled = false);
                clickedIcon.classList.remove('fa-pencil-alt');
                clickedIcon.classList.add('fa-check');
                currentlyEditingRoundIndex = roundIndexToEdit;
            }
        }


        function handleScoreInput(event) {
            const input = event.target;
            const roundIndex = parseInt(input.closest('tr').dataset.roundIndex);
            const playerIndex = parseInt(input.dataset.playerIndex);
            const score = parseInt(input.value) || 0; // Ensure it's a number, default to 0 if invalid

            if (!gameState.rounds[roundIndex]) {
                gameState.rounds[roundIndex] = new Array(gameState.playerCount).fill(0);
            }
            gameState.rounds[roundIndex][playerIndex] = score;
            saveGameState();
            updateTotals();

            // Visual feedback for score change
            input.classList.remove('score-changed'); // Remove to re-trigger animation if already present
            void input.offsetWidth; // Trigger reflow
            input.classList.add('score-changed');
            setTimeout(() => {
                input.classList.remove('score-changed');
            }, 500); // Remove class after animation duration
        }

        function handleInputFocus(event) {
            const input = event.target;
            const playerIndex = parseInt(input.dataset.playerIndex);
            const playerHeader = scoreTable.querySelector(`thead th[data-player-index="${playerIndex}"]`);

            input.classList.add('highlight-input');
            if (playerHeader) {
                playerHeader.classList.add('highlight-player-header');
            }
        }

        function handleInputBlur(event) {
            const input = event.target;
            const playerIndex = parseInt(input.dataset.playerIndex);
            const playerHeader = scoreTable.querySelector(`thead th[data-player-index="${playerIndex}"]`);

            input.classList.remove('highlight-input');
            if (playerHeader) {
                playerHeader.classList.remove('highlight-player-header');
            }
        }

        function updateTotals() {
            // Remove existing totals row if it exists
            const existingTotalsRow = document.getElementById('totalsRow');
            if (existingTotalsRow) {
                existingTotalsRow.remove();
            }

            const totals = new Array(gameState.playerCount).fill(0);
            gameState.rounds.forEach(roundScores => {
                roundScores.forEach((score, index) => {
                    totals[index] += score;
                });
            });

            const totalsRow = document.createElement('tr');
            totalsRow.id = 'totalsRow';
            totalsRow.className = 'font-bold bg-gray-200 dark:bg-gray-700 border-t-2 border-gray-400 dark:border-gray-500';

            const totalLabelTd = document.createElement('td');
            totalLabelTd.className = 'p-3 border-r border-gray-300 dark:border-gray-600 sticky-first-col rounded-bl-lg text-gray-800 dark:text-gray-200'; // Added text color classes
            totalLabelTd.textContent = 'Totals';
            totalsRow.appendChild(totalLabelTd);

            let highestScore = -Infinity;
            let lowestScore = Infinity;
            if (totals.length > 0) {
                highestScore = Math.max(...totals);
                lowestScore = Math.min(...totals);
            }

            const playerHeaderCells = scoreTable.querySelectorAll('thead tr th:not(:first-child)');

            // Reset highlighting on headers
            playerHeaderCells.forEach(th => {
                th.classList.remove('highlight-winner', 'highlight-loser'); // Use generic custom classes
            });

            // Check if all scores are zero to determine if highlighting should be applied
            const areAllScoresZero = totals.every(score => score === 0);

            totals.forEach((total, index) => {
                const td = document.createElement('td');
                td.className = 'p-3 border-r border-gray-200 dark:border-gray-700 text-center text-gray-800 dark:text-gray-200'; // Added text color classes
                td.textContent = total;

                // Apply highlighting to total score cell and player name header
                // only if not all scores are zero
                if (!areAllScoresZero) {
                    if (total === highestScore) {
                        td.classList.add('highlight-winner'); // Use generic custom class
                        playerHeaderCells[index].classList.add('highlight-winner'); // Use generic custom class
                    }
                    // Only apply loser highlight if it's genuinely the lowest and not also the highest (i.e., not all scores are the same)
                    if (total === lowestScore && highestScore !== lowestScore) {
                        td.classList.add('highlight-loser'); // Use generic custom class
                        playerHeaderCells[index].classList.add('highlight-loser'); // Use generic custom class
                    }
                }
                totalsRow.appendChild(td);
            });
            // Add rounded bottom-right corner to the last total cell
            totalsRow.querySelector('td:last-child').classList.add('rounded-br-lg');

            scoreTableBody.appendChild(totalsRow);
        }

        // --- Confirmation/Alert Modal Logic ---

        // Function to hide the confirmation modal and clear temporary event listeners
        function hideConfirmationModal() {
            confirmationModal.style.display = 'none';
        }

        // Function to display an alert-style modal (single OK button)
        function showAlertDialog(title, message, okText = 'OK') {
            confirmationModalTitle.textContent = title;
            confirmationModalMessage.textContent = message;

            confirmActionButton.textContent = okText;
            cancelActionButton.classList.add('hidden'); // Hide cancel button for alerts

            // Clear previous listeners to prevent multiple bindings if modal is reused
            confirmActionButton.onclick = null;
            closeConfirmationModalBtn.onclick = null;

            confirmActionButton.addEventListener('click', function _okHandler() {
                hideConfirmationModal();
                confirmActionButton.removeEventListener('click', _okHandler); // Clean up listener
            }, { once: true });

            closeConfirmationModalBtn.addEventListener('click', function _closeAlertHandler() {
                hideConfirmationModal();
                closeConfirmationModalBtn.removeEventListener('click', _closeAlertHandler); // Clean up listener
            }, { once: true });

            confirmationModal.style.display = 'flex';
        }

        // Function to display a confirmation-style modal (Confirm/Cancel buttons)
        function showConfirmationModal(title, message, confirmCallback) {
            confirmationModalTitle.textContent = title;
            confirmationModalMessage.textContent = message;

            confirmActionButton.textContent = 'Confirm';
            cancelActionButton.textContent = 'Cancel';
            cancelActionButton.classList.remove('hidden'); // Ensure cancel button is visible for confirmations

            // Clear previous listeners to prevent multiple bindings if modal is reused
            confirmActionButton.onclick = null;
            cancelActionButton.onclick = null;
            closeConfirmationModalBtn.onclick = null;

            confirmActionButton.addEventListener('click', function _confirmHandler() {
                confirmCallback();
                hideConfirmationModal();
                confirmActionButton.removeEventListener('click', _confirmHandler); // Clean up listener
            }, { once: true });

            cancelActionButton.addEventListener('click', function _cancelHandler() {
                hideConfirmationModal();
                cancelActionButton.removeEventListener('click', _cancelHandler); // Clean up listener
            }, { once: true });

            closeConfirmationModalBtn.addEventListener('click', function _closeConfirmHandler() {
                hideConfirmationModal();
                closeConfirmationModalBtn.removeEventListener('click', _closeConfirmHandler); // Clean up listener
            }, { once: true });

            confirmationModal.style.display = 'flex';
        }

        // Close modal if clicking outside (general handler, will coexist with specific button handlers)
        window.addEventListener('click', (event) => {
            if (event.target === confirmationModal) {
                hideConfirmationModal();
            }
        });


        // --- Tooltip Logic for Touch Devices ---
        function hideAllTooltips() {
            document.querySelectorAll('.tooltip-text.active').forEach(tooltip => {
                tooltip.classList.remove('active');
            });
        }

        // Event listener for clicks on the document to manage tooltips
        document.addEventListener('click', (event) => {
            const clickedElement = event.target;
            const isTooltipIcon = clickedElement.closest('.tooltip-container .fa-info-circle');
            const isTooltipText = clickedElement.closest('.tooltip-text');

            if (isTooltipIcon) {
                const tooltipId = isTooltipIcon.dataset.tooltipTarget;
                const tooltipText = document.getElementById(tooltipId);

                if (tooltipText) {
                    // If this tooltip is already active, hide it. Otherwise, hide others and show this one.
                    if (tooltipText.classList.contains('active')) {
                        tooltipText.classList.remove('active');
                    } else {
                        hideAllTooltips(); // Hide any other active tooltips
                        tooltipText.classList.add('active'); // Show this tooltip
                    }
                }
            } else if (!isTooltipText) {
                // If clicked outside any tooltip text, hide all active tooltips
                hideAllTooltips();
            }
        });

        // Add event listeners for the dark mode toggle button to show/hide tooltip on hover
        darkModeToggle.addEventListener('mouseenter', () => {
            document.getElementById('darkModeToggleTooltip').classList.add('active');
        });
        darkModeToggle.addEventListener('mouseleave', () => {
            document.getElementById('darkModeToggleTooltip').classList.remove('active');
        });


        // --- Event Handlers ---
        nextToPlayerNamesBtn.addEventListener('click', () => {
            const num = parseInt(numPlayersInput.value);
            if (isNaN(num) || num < 2 || num > 10) {
                playerCountError.classList.remove('hidden');
            } else {
                playerCountError.classList.add('hidden');
                gameState.playerCount = num;
                // Preserve existing player names if count matches, otherwise reset
                if (gameState.playerNames.length !== num) {
                    gameState.playerNames = new Array(num).fill('');
                }
                saveGameState();
                isEditingPlayerNames = false; // Ensure this is false for initial setup
                renderPlayerNamesScreen();
            }
        });

        backToPlayerCountBtn.addEventListener('click', () => {
            // Save current player names before going back
            const playerInputs = playerInputsContainer.querySelectorAll('input[type="text"]');
            playerInputs.forEach((input, index) => {
                gameState.playerNames[index] = input.value.trim();
            });
            saveGameState();
            renderPlayerCountScreen();
        });

        confirmPlayerNamesBtn.addEventListener('click', () => {
            const playerInputs = playerInputsContainer.querySelectorAll('input[type="text"]');
            let allNamesEntered = true;
            playerInputs.forEach((input, index) => {
                const name = input.value.trim();
                if (name === '') {
                    allNamesEntered = false;
                }
                gameState.playerNames[index] = name;
            });

            if (!allNamesEntered) {
                playerNamesError.classList.remove('hidden');
                playerNamesError.classList.remove('shake-animation'); // Remove to re-trigger
                void playerNamesError.offsetWidth; // Trigger reflow
                playerNamesError.classList.add('shake-animation');
            } else {
                playerNamesError.classList.add('hidden');
                playerNamesError.classList.remove('shake-animation'); // Ensure it's clean if successful

                if (isEditingPlayerNames) {
                    // If in editing mode, just save and go back to scoreboard
                    saveGameState();
                    isEditingPlayerNames = false; // Exit editing mode
                    renderScoreboard();
                } else {
                    // This is initial game setup
                    // If gameState.rounds already has data, it means we came from "Reset Game"
                    // and should clear rounds. Otherwise, it's a fresh start.
                    if (localStorage.getItem('cardGameScores') && gameState.rounds.length > 0) {
                         // User is starting a new game after a reset, clear scores
                         gameState.rounds = [];
                    }
                    saveGameState();
                    renderScoreboard();
                }
            }
        });

        addRoundBtn.addEventListener('click', () => {
            // Before adding a new round, ensure the previous last round is locked and its icon reset
            if (gameState.rounds.length > 0) {
                const previousLastRoundIndex = gameState.rounds.length - 1;
                const previousLastRoundRow = scoreTableBody.querySelector(`tr[data-round-index="${previousLastRoundIndex}"]`);
                if (previousLastRoundRow) {
                    const inputsInPreviousLastRow = previousLastRoundRow.querySelectorAll('input[type="number"]');
                    inputsInPreviousLastRow.forEach(input => input.disabled = true); // Lock inputs
                    const previousLastRoundEditIcon = previousLastRoundRow.querySelector('.edit-icon');
                    if (previousLastRoundEditIcon) {
                        previousLastRoundEditIcon.classList.remove('fa-check');
                        previousLastRoundEditIcon.classList.add('fa-pencil-alt');
                        previousLastRoundEditIcon.classList.remove('latest-round-active'); // Remove active style
                        // Ensure the click listener is added for toggling previous rounds
                        previousLastRoundEditIcon.removeEventListener('click', handleEditRoundClick); // Defensive remove
                        previousLastRoundEditIcon.addEventListener('click', handleEditRoundClick);
                    }
                }
            }

            const newRoundScores = new Array(gameState.playerCount).fill(0);
            gameState.rounds.push(newRoundScores);
            saveGameState();
            // Re-render the entire scoreboard to ensure all states are correctly applied
            renderScoreboard();
            updateTotals();
            // Scroll to the bottom to show the new round
            scoreTableBody.closest('.table-container').scrollTop = scoreTableBody.closest('.table-container').scrollHeight;
        });

        editPlayerNamesBtn.addEventListener('click', () => {
            isEditingPlayerNames = true; // Set flag to true for editing mode
            renderPlayerNamesScreen();
        });

        screenshotBtn.addEventListener('click', () => {
            screenshotLoadingModal.style.display = 'flex'; // Show loading modal

            const tableContainer = document.querySelector('.table-container');
            const scoreTableElement = document.getElementById('scoreTable');

            // Determine the current background color based on the active theme
            const currentBgColor = document.documentElement.classList.contains('dark') ? '#1a202c' : '#f0f4f8';

            // Store original styles
            const originalMaxHeight = tableContainer.style.maxHeight;
            const originalOverflow = tableContainer.style.overflow;

            // Temporarily remove max-height and overflow to capture full table
            tableContainer.style.maxHeight = 'none';
            tableContainer.style.overflow = 'visible';

            // Temporarily hide buttons and other elements not part of the table for a cleaner screenshot
            const scoreboardElement = document.getElementById('scoreboardScreen');
            const topButtonsContainer = scoreboardElement.querySelector('.flex.flex-wrap.justify-center.gap-x-4.gap-y-2.mb-6');
            const bottomButtonsContainer = scoreboardElement.querySelector('.flex.flex-wrap.justify-center.gap-x-4.gap-y-2.mt-6');

            const originalDisplayTopButtons = topButtonsContainer ? topButtonsContainer.style.display : '';
            const originalDisplayBottomButtons = bottomButtonsContainer ? bottomButtonsContainer.style.display : '';

            if (topButtonsContainer) topButtonsContainer.style.display = 'none';
            if (bottomButtonsContainer) bottomButtonsContainer.style.display = 'none';


            html2canvas(scoreTableElement, { // Target the actual table element
                scale: 2, // Increase scale for higher clarity
                useCORS: true, // Required if any images are loaded from external domains
                logging: false, // Disable logging for cleaner console
                backgroundColor: currentBgColor, // Set background dynamically based on theme
                // Set width and height to capture the full scrollable content
                width: scoreTableElement.scrollWidth,
                height: scoreTableElement.scrollHeight,
            }).then(canvas => {
                // Restore original styles
                tableContainer.style.maxHeight = originalMaxHeight;
                tableContainer.style.overflow = originalOverflow;

                // Restore hidden elements
                if (topButtonsContainer) topButtonsContainer.style.display = originalDisplayTopButtons;
                if (bottomButtonsContainer) bottomButtonsContainer.style.display = originalDisplayBottomButtons;

                screenshotLoadingModal.style.display = 'none'; // Hide loading modal

                const link = document.createElement('a');
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = now.toLocaleString('default', { month: 'short' }).toUpperCase();
                const year = now.getFullYear();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                link.download = `Score_${day}-${month}-${year}_${hours}${minutes}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click(); // Programmatically click the link to trigger download
                document.body.removeChild(link);
            }).catch(error => {
                console.error("Error generating screenshot:", error);
                // Restore original styles even on error
                tableContainer.style.maxHeight = originalMaxHeight;
                tableContainer.style.overflow = originalOverflow;

                // Restore hidden elements even on error
                if (topButtonsContainer) topButtonsContainer.style.display = originalDisplayTopButtons;
                if (bottomButtonsContainer) bottomButtonsContainer.style.display = originalDisplayBottomButtons;

                screenshotLoadingModal.style.display = 'none'; // Hide loading modal
            });
        });

        clearScoresBtn.addEventListener('click', () => {
            showConfirmationModal(
                'Clear All Scores?',
                'Are you sure? This will wipe the slate clean for all players, resetting every score to zero. This can\'t be undone.',
                () => {
                    gameState.rounds = [];
                    saveGameState();
                    renderScoreboard(); // Re-render to clear table rows
                }
            );
        });

        resetGameBtn.addEventListener('click', () => {
            showConfirmationModal(
                'Reset Game?',
                'Start from scratch? This will erase all players and scores permanently, taking you back to the very beginning. Are you ready for a fresh start?',
                () => {
                    localStorage.removeItem('cardGameScores');
                    gameState = {
                        playerCount: 0,
                        playerNames: [],
                        rounds: []
                    };
                    isEditingPlayerNames = false; // Reset flag
                    renderPlayerCountScreen(); // Go back to the very first screen
                }
            );
        });

        let roundsHidden = false; // State variable to track if rounds are hidden

        function applyHideShowRoundsState() {
            const allRoundRows = Array.from(scoreTableBody.querySelectorAll('tr:not(#totalsRow)'));
            const numRounds = allRoundRows.length;

            if (roundsHidden) {
                // Hide all except the last 3
                allRoundRows.forEach((row, index) => {
                    if (index < numRounds - 3) {
                        row.classList.add('hidden');
                    } else {
                        row.classList.remove('hidden'); // Ensure last 3 are visible
                    }
                });
                hideShowRoundsText.textContent = 'Show All Rounds';
                hideShowRoundsBtn.querySelector('i').className = 'fas fa-eye mr-2 group-scope-hover:scale-110 transition-transform';
                hideShowRoundsTooltip.textContent = 'Show all hidden rounds.';
            } else {
                // Show all
                allRoundRows.forEach(row => row.classList.remove('hidden'));
                hideShowRoundsText.textContent = 'Hide Old Rounds';
                hideShowRoundsBtn.querySelector('i').className = 'fas fa-eye-slash mr-2 group-scope-hover:scale-110 transition-transform';
                hideShowRoundsTooltip.textContent = 'Toggle visibility of old rounds (show last 3).';
            }
        }

        hideShowRoundsBtn.addEventListener('click', () => {
            roundsHidden = !roundsHidden; // Toggle the state
            applyHideShowRoundsState(); // Apply the new state
        });

        endGameBtn.addEventListener('click', () => {
            // Check if less than 15 rounds are played
            if (gameState.rounds.length < 15) {
                showAlertDialog(
                    'Game Not Ready',
                    `You need at least 15 rounds to finish the game. Current rounds: ${gameState.rounds.length}.`
                );
                return; // Stop execution if condition not met
            }

            const finalScores = new Array(gameState.playerCount).fill(0);
            gameState.rounds.forEach(roundScores => {
                roundScores.forEach((score, index) => {
                    finalScores[index] += score;
                });
            });

            // Create an array of objects { name, score, originalIndex }
            const playerScores = gameState.playerNames.map((name, index) => ({
                name: name,
                score: finalScores[index],
                originalIndex: index
            }));

            // Sort players by score in descending order
            playerScores.sort((a, b) => b.score - a.score);

            winnerResultsDiv.innerHTML = ''; // Clear previous results

            // Display results
            if (playerScores.length > 0) {
                winnerResultsDiv.innerHTML += `
                    <div class="flex items-center justify-center space-x-4 animate-bounce-in-1">
                        
                        <span class="text-4xl md:text-6xl">&#x1F947;</span>
                        <p class="text-2xl md:text-3xl font-bold text-green-600 dark:text-green-400">
                            Winner: ${playerScores[0].name} (${playerScores[0].score})
                        </p>
                       
                    </div>
                `;
            }
            if (playerScores.length > 1) {
                winnerResultsDiv.innerHTML += `
                    <div class="flex items-center justify-center space-x-3 animate-bounce-in-2">
                        <span class="text-4xl md:text-5xl">&#x1F948;</span>
                        <p class="text-xl md:text-2xl font-semibold text-blue-600 dark:text-blue-400">
                            2nd Place: ${playerScores[1].name} (${playerScores[1].score})
                        </p>
                    </div>
                `;
            }
            if (playerScores.length > 2) {
                winnerResultsDiv.innerHTML += `
                    <div class="flex items-center justify-center space-x-3 animate-bounce-in-3">
                        <span class="text-3xl md:text-4xl">&#x1F949;</span>
                        <p class="text-lg md:text-xl text-purple-600 dark:text-purple-400">
                            3rd Place: ${playerScores[2].name} (${playerScores[2].score})
                        </p>
                    </div>
                `;
            }

            winnerModal.style.display = 'flex'; // Show the modal
        });

        // Close modal event listeners
        closeWinnerModalBtn.addEventListener('click', () => {
            winnerModal.style.display = 'none';
        });
        closeWinnerModalBtn2.addEventListener('click', () => {
            winnerModal.style.display = 'none';
        });
        window.addEventListener('click', (event) => {
            if (event.target == winnerModal) {
                winnerModal.style.display = 'none';
            }
        });

        // Function to update the icon and text based on the theme
        function updateDarkModeUI() {
            if (document.documentElement.classList.contains('dark')) {
                darkModeIcon.classList.remove('fa-sun');
                darkModeIcon.classList.add('fa-moon');
                darkModeText.textContent = 'Light Mode';
            } else {
                darkModeIcon.classList.remove('fa-moon');
                darkModeIcon.classList.add('fa-sun');
                darkModeText.textContent = 'Dark Mode';
            }
        }

        // Dark Mode Toggle
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            document.documentElement.classList.toggle('light');
            // Update local storage for theme preference
            if (document.documentElement.classList.contains('dark')) {
                localStorage.setItem('theme', 'dark');
            } else {
                localStorage.setItem('theme', 'light');
            }
            // Update the icon and text to reflect the new theme
            updateDarkModeUI();
            // Re-render scoreboard to apply correct highlighting colors based on theme
            if (document.getElementById('scoreboardScreen').classList.contains('hidden') === false) {
                 updateTotals();
            }
        });

        // --- Initialization on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadGameState();

            // Apply saved theme preference or detect system preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.documentElement.classList.remove('light', 'dark');
                document.documentElement.classList.add(savedTheme);
            } else {
                // If no theme saved, detect system preference
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.classList.remove('light');
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    document.documentElement.classList.add('light');
                }
            }
            // Set the initial icon and text based on the loaded/detected theme
            updateDarkModeUI();

            if (gameState.playerCount > 0 && gameState.playerNames.length === gameState.playerCount) {
                renderScoreboard();
            } else if (gameState.playerCount > 0) {
                renderPlayerNamesScreen();
            } else {
                renderPlayerCountScreen();
            }
        });
    </script>
</body>
</html>